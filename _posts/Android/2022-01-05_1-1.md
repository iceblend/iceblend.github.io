---
title : 1-1. 코틀린 안드로이드 이해하기"
excerpt : "입사 전 안드로이드 및 코틀린 공부"
categories:
    - Android
tags:
    - [Android, Kotlin]
toc: true
toc_sticky : ture
date : 2022-01-05
last_modified_at : 2022-01-05
---

# Chapter 01. 코틀린 안드로이드 이해하기
## 1. 안드로이드 코틀린
- 안드로이드가 동작하는 플랫폼, 리눅스 커널, 현재 사용되고 있는 안드로이드의 
- API 레벨, 함수형 프로그래밍에 대해 알아보자.
### 1.1 운영체제와 플랫폼
- 안드로이드 플랫폼은 리눅스 운영체제 안에서 리눅스와 상호작용하면서 동작함.
- 전체 아키텍처 위쪽에 안드로이드가 실행되는 런타임 영역이 존재함.
### 1.2 플랫폼 버전과 API 레벨
- 안드로이드는 사용하는 플랫폼 버전과 별개로 API 레벨이 있음.
- API는 개발자에게 안드로이드 플랫폼의 기능을 사용할 수 있게 제공하는 도구.
- API 레벨의 변경 사항이 있을 때는 기존 코드 확인 필요.
### 1.3 코틀린
- 안드로이드 플랫폼의 구조 : 리눅스 커널 + 자바 API 프레임워크 결합
- 과거에 안드로이드 플랫폼에 대한 설명에는 JVM이 항상 따라 붙었는데 현재는 안드로이드 런타임을 사용함.
- 2017년 5월 구글에서 코틀린을 공식 언어로 채택함.
### 1.4 함수형 프로그램 언어 코틀린
- 코틀린은 함수형 프로그램을 표방.
### 1.5 안드로이드 개발에 있어서 자바와 코틀린의 차이
- 코틀린으로 작성하면 자바로 작성했을 때보다 코드의 양이 훨씬 적어짐.

## 2. 안드로이드 아키텍쳐
핵심 키워드 : 컴파일, 빌드, 런타임 APK

소스코드 ->(빌드)-> 앱 설치 파일 ->(등록)-> 앱스토어 ->(설치)-> 실행

안드로이드 스튜디오, 플레이 스토어, 안드로이드 스마트폰 까지도 하나의 거대한 안드로이드 플랫폼임.

### 2.1 소스 코드 작성에서 실행까지
1. 소스 코드 작성 : 코틀린으로 소스코드를 작성한다.
2. 설치 파일 생성 : 명령을 통해 안드로이드에서 실행될 수 있는 설치 파일의 형태로 변환.
3. 업로드 : 구글 플레이 스토어에 앱을 업로드 함.
4. 앱 등록 : 구글 플레이 스토어에 앱을 등록한다.
5. 앱 선택/설치 : 스마트폰으로 구글 플레이 스토어에 접속한 다음 설치할 앱을 선택/설치한다.
6. 스마트폰에서 실행: 아이콘을 터치해서 앱을 실행한다.

### 2.2 코드가 스마트폰에서 실행되는 과정
1. 빌드 (컴파일 + 비밀번호) : '설치 파일 생성' 단계는 빌드를 통해 진행한다. 이 과정에서 먼저 소스코드를 바이트 코드로 변환하며 APK 매니저에서 비밀번호를 가지고 있는 키 스토어와 조합해서 최종 설치파일을 생성한다.
2. 파일 검증 : '업로드' 단계로 단순히 파일을 업로드 하는데서 끝나는게 아니라 구글 플레이 스토어에서 앱을 검수하는 과정을 거친다. 이때 설치 파일이 정상적으로 동작하는지, 보안상의 문제는 없는지 등을 검사한다.
3. 플랫폼 버전 체크 : '앱 선택' 단계. 스마트폰으로 구글 플레이 스토어에 접속하면 스마트폰의 플랫폼 버전을 확인한 다음 설치 가능한 앱의 목록만 보여준다.
4. AOT 컴파일/설치 권한 체크 : '앱 설치' 단계. APK 파일을 설치하면 리눅스에서 실행 가능한 파일로 안드로이드폰 내부에서 한번 더 컴파일 한다. 이 과정을 통해 실행 속도가 빨라지며 사용자에게 기능의 사용 권한을 요청한다.
5. JIT 컴파일/실행권한 체크 : '스마트폰에서 실행' 단계. 4번째 단계에서 설치할 때는 필요한 파일만 컴파일한다. 그리고 첫 번째 앱을 실행할 때 미리 컴파일되지 않은 파일을 호출하면서 리눅스 실행 파일로 컴파일한다. 그리고 권한 중에 '실행 시 권한'이 포함되어 있으면 해등 코드가 동작해서 사용자에게 확인 요청을 함.

### 2.3 빌드
- 소스코드를 변환해서 안드로이드에서의 실행파일인 APK 파일로 만드는 것을 빌드(Build)라고 함.
- 컴파일이란?
    - 사람이 읽을 수 있는형태의 소스코드를 컴퓨터가 읽을 수 있는 형태의 기계어로 변환해주는 과정.
- 리눅스에서의 빌드
    - 소스코드를 컴파일하고 내가 만든 소스에서 사용하는 라이브러리와 연결해서 최종 실행 파일 형태로 만드는 것.
- 안드로이드에서의 빌드
    - 리눅스 컴파일과의 차이점은 안드로이드에서는 리소스(Resource)라는 개념이 있다는 점
    - 안드로이드는 2단계로 컴파일을 나눌 수 있음.
        - 1단계 : 바이트코드 단계. 소스코드, 리소스, 라이브러리를 한꺼번에 컴파일 함. 이때 생성된 파일은 안드로이드 플랫폼에서 인식할 수 있는 바이트코드로 컴파일 됨.
        - 2단계 : APK 파일 생성 단계. 1단계에서 생성된 파일을 APK 매니저라는 도구로 ㅅ개발자가 설정한 패스워드와 조합해서 설치 파일인 APK 파일로 만들어줌.
        - 1단계와 2단계를 모두 거쳐 APK 파일이 생성된 과정을 빌드라고 함.

### 2.4 설치와 실행
- 안드로이드 아키텍처는 앱 설치부터 실행 후 종료할 때까지 계속 따라다니면서 관여함.
- 설치 파일의 일부가 리눅스 운영체제에서 실행할 수 있는 파일형태로 한 번 더 컴파일되는데 이런 구조를 AOT(Ahead for Time)이라고 함.
- 앱을 실행되면 호출되는 파일 중에서 컴파일되지 않았던 파일이 한 번 더 컴파일 되는데 이 구조를 JIT(Just-in-time)이라고 함.
- 안드로이드는 AOT와 JIT라는 2개의 컴파일 형태를 같이 사용함으로써 효율성을 높이고 있음.

## 3. 새롭게 다루는 것들
기존 안드로이드에서 성능 및 사용성의 문제로 제거되는 것을 대체하기 위해 다음과 같은 요소를 새롭게 다룸.
- 젯팩 : 파편화되어 있는 수많은 버전에서 일관되게 동작하는 라이브러리 모음.
- 뷰 바인딩 : 전통적인 findViewById() 에서 코틀린 익스텐션으로 대체되었던 뷰에 대한 접근이 뷰 바인딩이라는 방식으로 대체됨.
- 코루틴 : 기존의 스레드를 대체하는 새로운 백그라운드 처리 방식.

### 3.1 젯팩
안드로이드는 모든 버전과 기기에서 일관되게 동작하는 젯팩(jetpack) 라이브러릴 제공.

- 젯팩을 사용하는 이유
    1. 하위 버전 호환성 : 최신 설계 방식을 바탕으로 빌드된 젯팩 라이브러리는 잊전 버전과의 호환성 기능이 통합되어 비정상 종료와 메모리 누수를 줄일 수 있게 해줌.
    2. 반복되는 코드 제거 : 개발자가 비즈니스 로직을 작성하는데 집중할 수 있도록 백그라운드 작업, 수명 주기 관리 등 반복적이고 지루한 코드를 제거해줌.
    3. 낮은 복잡도 : 모든 버전 및 기기에서 일관된 종작으로 코드의 복잡도를 낮춤.
- 젯팩 라이브러리 
    - 약 90개 정도의 라이브러리를 제공하며 아래의 라이브러리는 입문 단계에서 꼭 필요한 라이브러리
        - Collection
        - ConstraintLayout
        - Fragment
        - RecyclerView
        - ViewPager2
        - Preference
        - Room

### 3.2 뷰 바인딩
- 안드로이드 스튜디오 3.6 버전 부터는 코틀린 익스텐션을 개선한 뷰 바인딩(View Binding)을 지원한다.
- 뷰 바인딩은 레이아웃 파일이 사영되는 모든 곳에서 코틀린 익스텐션을 대체할 수 있는데, 액티비티(Activity)와 프래그먼트(Fragment), 어댑터(Adapter)에서 각각의 사용법이 조금씩 다름.

### 3.3 코루틴
- 백그라운드 처리를 위해 사용되든 쓰레드를 경량화한 코루틴이 제공됨.
- 기존의 스레드는 코루틴을 위해 실행 가능한 공간을 제공하는 역할만 하며, 하나의 스레드에 여러개의 코루틴이 존재할 수 있도록 설계.
- 2개 이상의 코루틴이 있을 때 프로세스 흐름이 코루틴 1에서 코루틴 2로 변경된다 하더라도 기존 스레드의 변경에서 발생할 수 이 ㅆ었던 성능저하는 더이상 발생하지 않음.
- 코루틴의 동작 범위를 설정하는 코루틴 스코프(Coroutine Scope)와 코루틴이 동작하는 스레드를 결정하는 디스패처(Dispatcher), 그리고 코루틴의 핵심이라고 할 수 있는 서스펜드(suspend) 키워드를 중점적으로 다룸.

